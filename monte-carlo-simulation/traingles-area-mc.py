from sympy import comp, deg


import linecache
import numpy as np

loc = ""

# Computes geometric area give three coordinates.
def geometric_area(x1,x2,x3):
    area = abs((0.5)*(x1[0]*(x2[1]-x3[1])+x2[0]*(x3[1]-x1[1])+x3[0]*(x1[1]-x2[1])))
    return area

# Gets points for nth triangle as mentioned in traingles.out file. If the files are not in the programs folder, location of folder containing triangles.out can be provided as "loc" variable.
def get_points(n, **kwargs):
    loc = kwargs.get('loc', "")
    triadd = loc + "triangles.out"
    pointadd = loc + "xygrid.out"
    line = linecache.getline(triadd, n).strip()
    line = line.split()
    points = []
    for i in line:
        point = linecache.getline(pointadd, int(i)).strip()
        point = point.split()
        point = [float(i) for i in point]
        points.append(point)
    return points

# Using monte-carlo

# To check if give point lies inside the give traingle
def check_point_inside(points, x):
    x1,x2,x3,xp,yp = points[0], points[1], points[2], x[0], x[1]
    c1 = (x2[0]-x1[0])*(yp-x1[1])-(x2[1]-x1[1])*(xp-x1[0])
    c2 = (x3[0]-x2[0])*(yp-x2[1])-(x3[1]-x2[1])*(xp-x2[0])
    c3 = (x1[0]-x3[0])*(yp-x3[1])-(x1[1]-x3[1])*(xp-x3[0])
    if (c1<0 and c2<0 and c3<0) or (c1>0 and c2>0 and c3>0):
        return 1
    else:
        return 0

# Obtain area by mote carlo simulation with N points
def mc_area(points, N):
    p1, p2, p3 = points
    lo_x = min(p1[0], p2[0], p3[0])
    hi_x = max(p1[0], p2[0], p3[0])
    lo_y = min(p1[1], p2[1], p3[1])
    hi_y = max(p1[1], p2[1], p3[1])
    rect_area = (hi_x - lo_x)*(hi_y - lo_y)
    total_inside = 0
    for _ in range(N):
        rand_x = np.random.uniform(low=lo_x, high=hi_x)
        rand_y = np.random.uniform(low=lo_y, high=hi_y)
        total_inside += check_point_inside(points, [rand_x, rand_y])
    area = (total_inside/N)*rect_area
    return area

# Total number of traingles
num_lines = sum(1 for line in open(loc + "triangles.out"))

def compute():
    # Open "f" for writing obtained geometric area and "g" for writing area obtained by monte-carlo method
    f = open("geometric_areas.out", "w")
    g = open("montecarlo_area.out", "w")

    for i in range(num_lines):
        p = get_points(i+1)
        g_area = geometric_area(p[0], p[1], p[2])
        m_area = mc_area(p, 1000)
        f.write(str(g_area))
        f.write("\n")
        g.write(str(m_area))
        g.write("\n")

# Obtaining difference in areas obtained geometrically and by monte-carlo method.
def difference(num_lines):
    diffs = []
    for i in range(num_lines):
        geo_area = float(linecache.getline("geometric_areas.out", i+1))
        mc_area = float(linecache.getline("montecarlo_area.out", i+1))
        diff = abs(geo_area- mc_area)
        diffs.append(diff)
    return diffs

# Get mean difference is areas calculated geometrically and by monte-carlo method.

# print(np.mean(difference(num_lines)))

# Computing volume using Pappu's Second Theorem which states that volume of a solid of revolution which is generated by rotating a plane figure about an external axis equal the area of the plane figure times the distance by the geometric centroid.

# Computes distance travelled by centroid of the 2d surface being sweeped.
def get_centroid_travel(p):
    centroid_x =  (p[0][0] + p[1][0] + p[2][0])/3
    dist = 2*np.pi*centroid_x
    return dist

# Calculating volume swept by triangle around a torus using Pappu's second theorem.
def volume_swept(num_lines):
    h = open("volumes.out", "w")
    for i in range(num_lines):
        p = get_points(i+1)
        area = float(linecache.getline("montecarlo_area.out", i+1))
        mult = get_centroid_travel(p)
        volume = area*mult
        h.write(str(volume))
        h.write("\n")

volume_swept(num_lines)



